# urlencode_functions.cfg

# Function: encode_char
# Given a single character in $1, sets the variable encoded_char
function encode_char {
  if [ "$1" = " " ]; then set encoded_char="%20"; return; fi
  if [ "$1" = "!" ]; then set encoded_char="%21"; return; fi
  if [ "$1" = "\"" ]; then set encoded_char="%22"; return; fi
  if [ "$1" = "#" ]; then set encoded_char="%23"; return; fi
  if [ "$1" = "\$" ]; then set encoded_char="%24"; return; fi
  if [ "$1" = "%" ]; then set encoded_char="%25"; return; fi
  if [ "$1" = "&" ]; then set encoded_char="%26"; return; fi
  if [ "$1" = "'" ]; then set encoded_char="%27"; return; fi
  if [ "$1" = "(" ]; then set encoded_char="%28"; return; fi
  if [ "$1" = ")" ]; then set encoded_char="%29"; return; fi
  if [ "$1" = "*" ]; then set encoded_char="%2A"; return; fi
  if [ "$1" = "+" ]; then set encoded_char="%2B"; return; fi
  if [ "$1" = "," ]; then set encoded_char="%2C"; return; fi
  if [ "$1" = "/" ]; then set encoded_char="%2F"; return; fi
  if [ "$1" = ":" ]; then set encoded_char="%3A"; return; fi
  if [ "$1" = ";" ]; then set encoded_char="%3B"; return; fi
  if [ "$1" = "<" ]; then set encoded_char="%3C"; return; fi
  if [ "$1" = "=" ]; then set encoded_char="%3D"; return; fi
  if [ "$1" = ">" ]; then set encoded_char="%3E"; return; fi
  if [ "$1" = "?" ]; then set encoded_char="%3F"; return; fi
  if [ "$1" = "@" ]; then set encoded_char="%40"; return; fi
  if [ "$1" = "[" ]; then set encoded_char="%5B"; return; fi
  if [ "$1" = "\\" ]; then set encoded_char="%5C"; return; fi
  if [ "$1" = "]" ]; then set encoded_char="%5D"; return; fi
  if [ "$1" = "^" ]; then set encoded_char="%5E"; return; fi
  if [ "$1" = "\`" ]; then set encoded_char="%60"; return; fi
  if [ "$1" = "{" ]; then set encoded_char="%7B"; return; fi
  if [ "$1" = "|" ]; then set encoded_char="%7C"; return; fi
  if [ "$1" = "}" ]; then set encoded_char="%7D"; return; fi
  # Fallback if not explicitly handled:
  set encoded_char="%00"
}

# Function: urlencode
# Usage: urlencode "string"
# Returns the encoded result in the variable 'encoded'
function urlencode {
  set encoded=""
  set i=0
  set input="$1"
  while [ $i -lt ${#input} ]; do
    # Extract one character from input.
    set char=${input:$i:1}
    # Check if char is unreserved.
    regexp "^[A-Za-z0-9_.~-]$" "$char" allowed
    if [ "$allowed" ]; then
      set encoded="${encoded}${char}"
    else
      encode_char "$char"
      set encoded="${encoded}${encoded_char}"
    fi
    set i=$(($i+1))
  done
}
